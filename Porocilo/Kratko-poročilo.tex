\documentclass[a4paper,15pt]{article}
\usepackage[slovene]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{amsmath}
\pagenumbering{arabic}
\usepackage{wrapfig}
\usepackage{tabularx}
\usepackage[table]{xcolor}
\usepackage{amsfonts}
\usepackage{lipsum}
\usepackage{amsmath,amsthm}
\usepackage{ragged2e}
\usepackage{framed}
\usepackage{amssymb}


\newtheorem{theorem}{Izrek}

\title{ \textbf{ Štetje rešitev klasičnega problema nahrbtnika} \\
  \large Kratko poročilo pri predmetu Finančni praktikum}
\author{Kristina Vatovec in Žan Mikola}
\date{December 2020}

\begin{document}
\begin{titlepage}
\maketitle
\thispagestyle{empty}
\pagestyle{empty}
\end{titlepage}


\section{Opis problema}


Podanih je n elementov  z celoštevilskimi težami \(w_{1},...,w_{n}\) in kapaciteto C, ki je prav tako celo število  Privzemimo štetje klasičnega problema nahrbtnika.
S pomočjo algoritma, ki temelji na dinamičnem programiranju želimo poiskati oceno za  število rešitev problema znotraj relativne napake \(1 \pm \epsilon\)  v polinomskem času n in \(1/\epsilon\).
 
\vspace{3mm}
\noindent Preden nadaljujemo, omenimo naslednji izrek, ki je bistvenega pomena pri samem problemu.

\begin{theorem} 
Podane so teže \(w_{1},...,w_{n}\) in kapaciteta C pri problemu nahrbtnika. Naj bo Z število rešitev problema. Obstaja deterministični algoritem, ki za vsak \( \epsilon \in [0,1]\) vrne \(\uppercase{z}^{'} \)za katerega velja  
\( \uppercase{z} \leq \uppercase{z}^{'} \leq \uppercase{z}(1 + \epsilon) \) .

\end{theorem}


\noindent Poglejmo si še funkcijo $T : \{0, \ldots, n\} \times \{0, \ldots, s\} \rightarrow \mathbb{R}_{\geq 0} \cup \{\infty \}  $ , ki je definirana v spodnjem algoritmu.

\begin{framed}
Vhod: Celaštevila \(w_{1},...,w_{n}\), C in \( \epsilon > 0\).
\begin{enumerate}
\item Postavimo \(\uppercase{t}[0,0] = 0\) and \(\uppercase{t}[o,j] = \infty \) za \(j > 0\).
\item Postavimo \( \uppercase{q} = ( 1+ \epsilon/(n + 1))\) in \( s= \lceil n log_{\uppercase{q}}2 \rceil\).
\item Za \( i = 1 \to n\), za \( j = 0 \to s \), postavim

\[ 
\uppercase{t}[i, j]=\ min_{\alpha \in [0,1]} max \left\{
\begin{array}{ll}
      \uppercase{t}[i - 1, \lceil j + log_{\uppercase{q}}\alpha \rceil ], \\
      \uppercase{t}[i - 1, \lceil j + log_{\uppercase{q}}(1 - \alpha) \rceil ] + w_{i}, 
      
\end{array} 
\right. 
\]
kjer po dogovoru velja \( \uppercase{t}[i - 1, k] = 0 \) za \( k <0\).

\item Naj bo
\[
j^{'} := max\{j : \uppercase{t}[n, j] \leq \uppercase{C} \}.
\]
\item Izhod \(\uppercase{Z}^{'} := \uppercase{Q}^{j^{'} + 1} \)
\end{enumerate}
\end{framed}



\noindent Pri iskanju minimuna funkcije T v odvisnost od parametra $\alpha \in [0,1]$, je v resnici dovolj gledati le $\alpha$, ki ustrezajo vrednostim diskretne množice $S$. Za $ j \in \{0, 1, \ldots, s\}$, je množiča $S = S_{1} \cup S_{2}$, kjer $S_{1} = \{Q^{-j}, \ldots, Q^0\}$ in $S_{2} = \{1-Q^{0}, \ldots, 1- Q^{-j}\}$. \\
\vspace{3mm}\\
\noindent Izkaže se, da izhodni podatek \(\uppercase{z}^{'}\) zadošča zgoraj napisanem izreku, kar pa je tisto, kar si želimo pri algoritmu za naš problem.\\

\vspace{3mm}
\noindent V tem algoritmu smo uporabili funkcijo T, vendar na prvi pogled ni povsem jasno kaj pomeni vrednost, ki jo vrne. Fukcija  je T je torej aproksimacijska funkcija funkcije $\tau$.  Funkcija $\tau :  \{0, \ldots, n\} \times \mathbb{R}_{\geq 0}  \rightarrow \mathbb{R} \cup \{\pm \infty \} $, kjer $\tau (i,a )$ vrne najmanjši $C$, Pri katerem obstaja vsaj $a$ rešitev problema nahrbtnika z težami $ \omega_{1} \ldots \omega_{n}$ in kapaciteto $C$. Fukcijo $\tau$ ne znamo efektivno izračunati, zato definiramo fukcijo $T$. \\
 

\noindent Torej točno število rešitev problema nahrbtnika je $$Z= max\{a: \tau (n,a) \leq C\} $$

\section{Načrt dela}

\noindent Naloga, ki sva si jo zastavila v prihodnje je implementacija zgornjega algoritma. Algoritem bova napisala v programskem jeziku Python.
Ko bova algoritem pripravila, sledi eksperimentalni del. Poskušala, bova ugotoviti ali pri različnih vhodnih podatkih prihaja do sprememb v časovni zahtevnosti. 
  \vspace{3mm} \\
Pri samem programiranju bo največja težava napisati algoritem, ki bo v uglednem času ocenil število rešitev za večje število elementov, ki lahko damo v nahrbtnik. Sama rešitev $Z^{'}$, največkrat ne bo vračala naravnih števil, vendar bomo lahko zaradi enakosti v Izreku 1 lahko ocenili dano rešitev.
\vspace{3mm}\\
Ko bova končala z algoritmom, ga bova morala še testirati. V ta namen bova naredila generator podatkov, ki bo izbral naključno število elemntov in podal nijhove teže, ter izbral naključno težo nahrbtnika. Pričakujeva, da bo za velike $n$ program počasen, saj je njegova računska zahtevnost polinomska.






\end{document}
